% Generated by ADiMat 0.6.6-5530 (00419e1f)
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to johannes@johannes-willkomm.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_XML  -- Write list of unbound identifiers in XML format.
% DEPENDENCIES_XML  -- Write list of functions in XML format.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% FUNCTION_LIST_XML	-- Write list of functions to XML file.
% VERBOSITYLEVEL=5
% AD_IVARS= uN1, k, dimension, J, dNrAll, DMat, gaussWeight
% AD_DVARS= Re

function [g_Re, Re]= g_gaussDisplacementHookeEnpoint(g_uN1, uN1, g_k, k, g_dimension, dimension, g_J, J, g_dNrAll, dNrAll, g_DMat, DMat, g_gaussWeight, gaussWeight)
   indx= dimension* k- (dimension- 1): dimension* k; 
   g_tmp_J_00000= g_J(: , indx);
   tmp_J_00000= J(: , indx);
   detJ= det(tmp_J_00000' ); 
   g_detJ= detJ* call(@trace, inv(tmp_J_00000' )* g_tmp_J_00000' );
   if detJ< 10* eps
      error('Jacobi determinant equal or less than zero.')
   end
   g_tmp_J_00001= g_J(: , indx);
   tmp_J_00001= J(: , indx);
   g_tmp_dNrAll_00000= g_dNrAll(indx, : );
   tmp_dNrAll_00000= dNrAll(indx, : );
   g_dNx= adimat_g_mldivide((g_tmp_J_00001' ), (tmp_J_00001' ), g_tmp_dNrAll_00000, tmp_dNrAll_00000);
   dNx= (tmp_J_00001' )\ tmp_dNrAll_00000; 
   numberOfNodes= size(dNx, 2); 
   numberOfDisplacementDofs= numberOfNodes* dimension; 
   numberOfSymmetricVoigtDofs= dimension+ (dimension^ 2- dimension)/ 2; 
   B= zeros(numberOfSymmetricVoigtDofs, numberOfDisplacementDofs); 
   g_B= g_zeros(size(B));
   g_tmp_dNx_00000= g_dNx(1, : );
   tmp_dNx_00000= dNx(1, : );
   g_B(1, 1: dimension: end)= g_tmp_dNx_00000;
   B(1, 1: dimension: end)= tmp_dNx_00000; 
   g_tmp_dNx_00001= g_dNx(2, : );
   tmp_dNx_00001= dNx(2, : );
   g_B(2, 2: dimension: end)= g_tmp_dNx_00001;
   B(2, 2: dimension: end)= tmp_dNx_00001; 
   g_tmp_dNx_00002= g_dNx(3, : );
   tmp_dNx_00002= dNx(3, : );
   g_B(3, 3: dimension: end)= g_tmp_dNx_00002;
   B(3, 3: dimension: end)= tmp_dNx_00002; 
   g_tmp_dNx_00003= g_dNx(2, : );
   tmp_dNx_00003= dNx(2, : );
   g_B(4, 1: dimension: end)= g_tmp_dNx_00003;
   B(4, 1: dimension: end)= tmp_dNx_00003; 
   g_tmp_dNx_00004= g_dNx(1, : );
   tmp_dNx_00004= dNx(1, : );
   g_B(4, 2: dimension: end)= g_tmp_dNx_00004;
   B(4, 2: dimension: end)= tmp_dNx_00004; 
   g_tmp_dNx_00005= g_dNx(3, : );
   tmp_dNx_00005= dNx(3, : );
   g_B(5, 2: dimension: end)= g_tmp_dNx_00005;
   B(5, 2: dimension: end)= tmp_dNx_00005; 
   g_tmp_dNx_00006= g_dNx(2, : );
   tmp_dNx_00006= dNx(2, : );
   g_B(5, 3: dimension: end)= g_tmp_dNx_00006;
   B(5, 3: dimension: end)= tmp_dNx_00006; 
   g_tmp_dNx_00007= g_dNx(3, : );
   tmp_dNx_00007= dNx(3, : );
   g_B(6, 1: dimension: end)= g_tmp_dNx_00007;
   B(6, 1: dimension: end)= tmp_dNx_00007; 
   g_tmp_dNx_00008= g_dNx(1, : );
   tmp_dNx_00008= dNx(1, : );
   g_B(6, 3: dimension: end)= g_tmp_dNx_00008;
   B(6, 3: dimension: end)= tmp_dNx_00008; 
   g_tmp_gaussDisplacementHookeEnpoint_00000= g_B' * DMat* B+ B' * g_DMat* B+ B' * DMat* g_B;
   tmp_gaussDisplacementHookeEnpoint_00000= B' * DMat* B;
   g_tmp_gaussWeight_00000= g_gaussWeight(k);
   tmp_gaussWeight_00000= gaussWeight(k);
   g_Re= g_tmp_gaussDisplacementHookeEnpoint_00000* uN1* detJ* tmp_gaussWeight_00000+ tmp_gaussDisplacementHookeEnpoint_00000* g_uN1* detJ* tmp_gaussWeight_00000+ tmp_gaussDisplacementHookeEnpoint_00000* uN1* g_detJ* tmp_gaussWeight_00000+ tmp_gaussDisplacementHookeEnpoint_00000* uN1* detJ* g_tmp_gaussWeight_00000;
   Re= tmp_gaussDisplacementHookeEnpoint_00000* uN1* detJ* tmp_gaussWeight_00000; 
   % Ke = (B'*DMat*B)*detJ*gaussWeight(k);
end
